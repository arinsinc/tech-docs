# 1D Dynamic Programming

## ğŸ“‹ Overview

**1D Dynamic Programming** refers to problems where the optimal solution can be computed using a single array (one-dimensional state). These problems typically involve sequences, where each decision depends on previous states in a linear fashion. The DP array stores intermediate results to avoid redundant calculations.

---

## ğŸ¯ Core Concepts

### What is 1D DP?

In 1D DP:
- **State** is represented by a single index (usually position or count)
- **DP array** is one-dimensional: `dp[i]`
- **Transition** depends on previous elements: `dp[i-1]`, `dp[i-2]`, etc.
- **Result** is typically in `dp[n]` or combination of DP values

**Characteristics:**
- ğŸ¯ Linear dependency structure
- ğŸ“Š One index to track state
- âš¡ Space can often be optimized to O(1)
- ğŸ”„ Can be solved iteratively (bottom-up) or recursively (top-down)

---

## ğŸ¨ Visual Understanding

### Basic 1D DP Structure

```
Problem: Find something optimal up to position i

DP Array:
Index:  0    1    2    3    4    5    6
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
dp:   â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
       â†‘
     Base case

Direction of computation: â†’

Each dp[i] depends on previous states:
dp[i] = f(dp[i-1], dp[i-2], ..., dp[0])
```

### State Transition Visualization

```
Computing dp[5]:

Previous States:    Current:    Result:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”
â”‚dp[2]â”‚dp[3]â”‚dp[4]â”‚ â†’ â”‚ ?  â”‚ â†’ â”‚dp[5]â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜
                      â†‘
                Uses formula/logic
                based on previous

Example: dp[5] = max(dp[4] + arr[5], dp[3])
```

---

## ğŸ“š Classic 1D DP Problems

### 1. Fibonacci Sequence

**Problem:** Find nth Fibonacci number where F(n) = F(n-1) + F(n-2)

**Recurrence Relation:**
```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)
```

**Visual Example - Calculate F(6):**
```
Sequence: 0, 1, 1, 2, 3, 5, 8, ...

DP Array Construction:
n:     0    1    2    3    4    5    6
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
F(n): â”‚ 0  â”‚ 1  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
      â†‘    â†‘
    Base cases

Step 1: F(2) = F(1) + F(0) = 1 + 0 = 1
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
     â”‚ 0  â”‚ 1  â”‚ 1  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Step 2: F(3) = F(2) + F(1) = 1 + 1 = 2
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
     â”‚ 0  â”‚ 1  â”‚ 1  â”‚ 2  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Step 3: F(4) = F(3) + F(2) = 2 + 1 = 3
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
     â”‚ 0  â”‚ 1  â”‚ 1  â”‚ 2  â”‚ 3  â”‚ ?  â”‚ ?  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Step 4: F(5) = F(4) + F(3) = 3 + 2 = 5
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
     â”‚ 0  â”‚ 1  â”‚ 1  â”‚ 2  â”‚ 3  â”‚ 5  â”‚ ?  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Step 5: F(6) = F(5) + F(4) = 5 + 3 = 8
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
     â”‚ 0  â”‚ 1  â”‚ 1  â”‚ 2  â”‚ 3  â”‚ 5  â”‚ 8  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Result: F(6) = 8
```

**Space Optimization:**
```
Only need last 2 values:

prev2 = 0, prev1 = 1

For n = 2: current = 0 + 1 = 1
           prev2 = 1, prev1 = 1

For n = 3: current = 1 + 1 = 2
           prev2 = 1, prev1 = 2

For n = 4: current = 1 + 2 = 3
           prev2 = 2, prev1 = 3

...and so on

Space: O(n) â†’ O(1) âœ“
```

---

### 2. Climbing Stairs

**Problem:** You're climbing stairs with n steps. You can climb 1 or 2 steps at a time. How many distinct ways to reach the top?

**Visual Example - n = 5 stairs:**
```
Stairs:
     â”Œâ”€â”€â”€ 5 (Goal)
     â”‚
     â”œâ”€â”€â”€ 4
     â”‚
     â”œâ”€â”€â”€ 3
     â”‚
     â”œâ”€â”€â”€ 2
     â”‚
     â”œâ”€â”€â”€ 1
     â”‚
     â””â”€â”€â”€ 0 (Start)

Ways to reach each step:
Step 0: 1 way (you're already there)
Step 1: 1 way (0â†’1)
Step 2: 2 ways (0â†’1â†’2, 0â†’2)
Step 3: 3 ways (from step 1 or step 2)
Step 4: 5 ways
Step 5: 8 ways
```

**DP Array:**
```
dp[i] = ways to reach step i
dp[i] = dp[i-1] + dp[i-2]
        (come from 1 step back OR 2 steps back)

Step:  0    1    2    3    4    5
     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
ways:â”‚ 1  â”‚ 1  â”‚ 2  â”‚ 3  â”‚ 5  â”‚ 8  â”‚
     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Step 2: Can come from step 0 (jump 2) or step 1 (jump 1)
        ways[2] = ways[0] + ways[1] = 1 + 1 = 2

Step 3: Can come from step 1 or step 2
        ways[3] = ways[1] + ways[2] = 1 + 2 = 3

Result: 8 distinct ways to climb 5 stairs
```

**This is Fibonacci!** Same pattern as Fibonacci numbers.

---

### 3. House Robber

**Problem:** Houses in a row, each with money. Can't rob adjacent houses. Maximize money robbed.

**Visual Example:**
```
Houses: [2, 7, 9, 3, 1]
         â†‘  â†‘  â†‘  â†‘  â†‘
       H0 H1 H2 H3 H4

Decision at each house:
- Rob it: get its money + max from 2 houses before
- Skip it: keep max from previous house

DP Array (max money up to house i):
House:  0    1    2    3    4
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
Money:â”‚ 2  â”‚ 7  â”‚ 9  â”‚ 3  â”‚ 1  â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
dp:   â”‚ 2  â”‚ 7  â”‚ 11 â”‚ 11 â”‚ 12 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Step-by-step:
House 0: dp[0] = 2 (rob house 0)

House 1: dp[1] = max(rob H1, don't rob H1)
               = max(7, 2)
               = 7 (rob house 1, skip house 0)

House 2: dp[2] = max(rob H2, don't rob H2)
               = max(9 + dp[0], dp[1])
               = max(9 + 2, 7)
               = max(11, 7) = 11
               (rob houses 0 and 2)

House 3: dp[3] = max(3 + dp[1], dp[2])
               = max(3 + 7, 11)
               = max(10, 11) = 11
               (don't rob house 3)

House 4: dp[4] = max(1 + dp[2], dp[3])
               = max(1 + 11, 11)
               = max(12, 11) = 12
               (rob houses 0, 2, and 4)

Maximum money: 12
Houses robbed: H0(2) + H2(9) + H4(1) = 12
```

**Recurrence:**
```
dp[i] = max(nums[i] + dp[i-2], dp[i-1])
         â†‘                      â†‘
     Rob current house    Skip current house
```

---

### 4. Maximum Subarray (Kadane's Algorithm)

**Problem:** Find contiguous subarray with maximum sum.

**Visual Example - Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]**
```
At each position, decide:
- Extend previous subarray
- Start new subarray from current

Index:  0    1    2    3    4    5    6    7    8
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
arr:  â”‚ -2 â”‚ 1  â”‚ -3 â”‚ 4  â”‚ -1 â”‚ 2  â”‚ 1  â”‚ -5 â”‚ 4  â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
dp:   â”‚ -2 â”‚ 1  â”‚ -2 â”‚ 4  â”‚ 3  â”‚ 5  â”‚ 6  â”‚ 1  â”‚ 5  â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
       â†‘                       â†‘         â†‘
   Start here          Continue    Best sum: 6

dp[i] = max sum ending at position i

Step-by-step:
i=0: dp[0] = -2 (only element)

i=1: dp[1] = max(1, -2 + 1)
           = max(1, -1) = 1
           (start new subarray)

i=2: dp[2] = max(-3, 1 + (-3))
           = max(-3, -2) = -2
           (extend: [1, -3])

i=3: dp[3] = max(4, -2 + 4)
           = max(4, 2) = 4
           (start new: [4])

i=4: dp[4] = max(-1, 4 + (-1))
           = max(-1, 3) = 3
           (extend: [4, -1])

i=5: dp[5] = max(2, 3 + 2)
           = max(2, 5) = 5
           (extend: [4, -1, 2])

i=6: dp[6] = max(1, 5 + 1)
           = max(1, 6) = 6 â† Maximum!
           (extend: [4, -1, 2, 1])

i=7: dp[7] = max(-5, 6 + (-5))
           = max(-5, 1) = 1
           (extend: [4, -1, 2, 1, -5])

i=8: dp[8] = max(4, 1 + 4)
           = max(4, 5) = 5
           (extend: [4, -1, 2, 1, -5, 4])

Maximum sum: 6
Subarray: [4, -1, 2, 1]
```

**Key Insight:**
```
At each position:
    maxEndingHere = max(current, maxEndingHere + current)
    maxSoFar = max(maxSoFar, maxEndingHere)

Visualization:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ maxEndingHere  â”‚ â† Sum of best subarray ending here
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   maxSoFar     â”‚ â† Best sum seen anywhere
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5. Coin Change

**Problem:** Given coin denominations, find minimum coins to make amount.

**Visual Example - Coins: [1, 2, 5], Amount: 11**
```
DP Array: dp[i] = minimum coins to make amount i

Amount:  0    1    2    3    4    5    6    7    8    9   10   11
       â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
dp:    â”‚ 0  â”‚ 1  â”‚ 1  â”‚ 2  â”‚ 2  â”‚ 1  â”‚ 2  â”‚ 2  â”‚ 3  â”‚ 3  â”‚ 2  â”‚ 3  â”‚
       â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Building dp[11]:

For each amount i, try each coin:
  dp[i] = min(dp[i], dp[i - coin] + 1)

Amount 0: 0 coins (base case)

Amount 1: Try each coin:
  - Coin 1: dp[1-1] + 1 = dp[0] + 1 = 1 âœ“
  - Coin 2: Can't use (2 > 1)
  - Coin 5: Can't use (5 > 1)
  Result: 1 coin [1]

Amount 2: Try each coin:
  - Coin 1: dp[2-1] + 1 = dp[1] + 1 = 2
  - Coin 2: dp[2-2] + 1 = dp[0] + 1 = 1 âœ“
  Result: 1 coin [2]

Amount 5:
  - Coin 1: dp[5-1] + 1 = dp[4] + 1 = 3
  - Coin 2: dp[5-2] + 1 = dp[3] + 1 = 3
  - Coin 5: dp[5-5] + 1 = dp[0] + 1 = 1 âœ“
  Result: 1 coin [5]

Amount 11:
  - Coin 1: dp[11-1] + 1 = dp[10] + 1 = 3
  - Coin 2: dp[11-2] + 1 = dp[9] + 1 = 4
  - Coin 5: dp[11-5] + 1 = dp[6] + 1 = 3 âœ“
  Result: 3 coins [5, 5, 1]

Minimum coins for 11: 3
Solution: [5, 5, 1] or [5, 2, 2, 2]
```

**Visual Decision Tree for Amount 11:**
```
                    11
                 /  |  \
              10   9    6  (subtract each coin)
            /||\  /|\  /|\
           ...  ... ...

Pick path with minimum total coins:
11 â†’ 6 (coin 5) â†’ 1 (coin 5) â†’ 0 (coin 1)
3 coins used
```

---

### 6. Longest Increasing Subsequence (LIS)

**Problem:** Find length of longest strictly increasing subsequence.

**Visual Example - Array: [10, 9, 2, 5, 3, 7, 101, 18]**
```
DP Array: dp[i] = length of LIS ending at index i

Index:  0    1    2    3    4    5    6    7
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
arr:  â”‚ 10 â”‚ 9  â”‚ 2  â”‚ 5  â”‚ 3  â”‚ 7  â”‚101 â”‚ 18 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
dp:   â”‚ 1  â”‚ 1  â”‚ 1  â”‚ 2  â”‚ 2  â”‚ 3  â”‚ 4  â”‚ 4  â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

For each position i, check all previous j < i:
  If arr[j] < arr[i]:
    dp[i] = max(dp[i], dp[j] + 1)

Position 0: dp[0] = 1 (just [10])

Position 1: arr[1] = 9
  - 9 < 10? No
  dp[1] = 1 (just [9])

Position 2: arr[2] = 2
  - 2 < 10? Yes, but dp[0] + 1 = 2
  - 2 < 9? Yes, but dp[1] + 1 = 2
  dp[2] = 1 (just [2])

Position 3: arr[3] = 5
  - 5 < 10? Yes: dp[0] + 1 = 2
  - 5 < 9? Yes: dp[1] + 1 = 2
  - 5 < 2? No
  dp[3] = 2 (sequences: [10, 5] or [9, 5] or [2, 5])

Position 5: arr[5] = 7
  - Check all previous:
    - 10 < 7? No
    - 9 < 7? No
    - 2 < 7? Yes: dp[2] + 1 = 2
    - 5 < 7? Yes: dp[3] + 1 = 3 âœ“
    - 3 < 7? Yes: dp[4] + 1 = 3
  dp[5] = 3 (sequence: [2, 5, 7])

Position 6: arr[6] = 101
  - 7 < 101? Yes: dp[5] + 1 = 4 âœ“
  dp[6] = 4 (sequence: [2, 5, 7, 101])

Position 7: arr[7] = 18
  - 7 < 18? Yes: dp[5] + 1 = 4 âœ“
  dp[7] = 4 (sequence: [2, 5, 7, 18])

Longest length: 4
One possible LIS: [2, 5, 7, 18]
Another: [2, 5, 7, 101]
```

**Visual Subsequences:**
```
Array: [10, 9, 2, 5, 3, 7, 101, 18]

Some increasing subsequences:
[2] length 1
[2, 5] length 2
[2, 5, 7] length 3
[2, 5, 7, 18] length 4 âœ“
[2, 5, 7, 101] length 4 âœ“
[2, 3, 7, 18] length 4 âœ“

Longest: 4
```

---

### 7. Word Break

**Problem:** Given string and dictionary, can string be segmented into dictionary words?

**Visual Example - String: "leetcode", Dictionary: ["leet", "code"]**
```
DP Array: dp[i] = can substring [0...i) be segmented?

String: l e e t c o d e
Index:  0 1 2 3 4 5 6 7 8
      â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
dp:   â”‚ T â”‚ F â”‚ F â”‚ F â”‚ T â”‚ F â”‚ F â”‚ F â”‚ T â”‚
      â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
       â†‘                   â†‘               â†‘
    empty              "leet"        "leetcode"
    (base)              found          found

Step-by-step:
dp[0] = true (empty string, base case)

dp[1]: Check "l"
  - "l" in dictionary? No
  dp[1] = false

dp[2]: Check "le"
  - "le" in dictionary? No
  - "l" + "e"? dp[1] = false
  dp[2] = false

dp[4]: Check "leet"
  - "leet" in dictionary? Yes! âœ“
  - dp[0] = true, so dp[4] = true
  (empty + "leet" works)

dp[8]: Check "leetcode"
  Try all splits:
  - "" + "leetcode"? Not in dict
  - "l" + "eetcode"? dp[1]=false
  - "le" + "etcode"? dp[2]=false
  - "lee" + "tcode"? dp[3]=false
  - "leet" + "code"? dp[4]=true and "code" in dict âœ“
  
  dp[8] = true

Result: Yes, can be segmented as "leet" + "code"
```

**Visual Splits:**
```
"leetcode"
    â†“
   / \
"leet" "code"
  âœ“     âœ“
Both in dictionary!

vs.

"leetcode"
    â†“
   / \
"le" "etcode"
 âœ—     âœ—
Neither in dictionary
```

---

## ğŸ¯ Problem-Solving Patterns

### Pattern 1: Linear Sequence Decision

**When to Use:**
- Each position has a decision
- Decision affects future choices linearly
- Previous states determine current state

**Examples:**
- Climbing stairs
- House robber
- Maximum subarray

**Template:**
```
dp[i] = decision based on dp[i-1], dp[i-2], etc.
```

---

### Pattern 2: Subsequence Problems

**When to Use:**
- Finding optimal subsequence
- Elements don't need to be consecutive
- Order matters

**Examples:**
- Longest increasing subsequence
- Longest common subsequence (with 1D optimization)

**Template:**
```
For each position i:
  Check all previous positions j < i
  dp[i] = optimize(dp[j] + contribution)
```

---

### Pattern 3: Partition/Break Problems

**When to Use:**
- Breaking string/array into parts
- Each part satisfies some condition
- Need to check if partition possible

**Examples:**
- Word break
- Palindrome partitioning
- Decode ways

**Template:**
```
For each position i:
  Try all possible previous split points j
  if (valid segment [j, i]):
    dp[i] = combine(dp[j], segment)
```

---

### Pattern 4: Target Sum Problems

**When to Use:**
- Reaching a target value
- Multiple ways to reach target
- Count or optimize ways

**Examples:**
- Coin change
- Combination sum
- Target sum

**Template:**
```
For each target value i:
  For each choice:
    dp[i] = optimize(dp[i], dp[i - choice] + cost)
```

---

## ğŸ’¡ Space Optimization Techniques

### Rolling Array

**Concept:** Keep only necessary previous states.

```
Before (Full Array):
dp[0], dp[1], dp[2], ..., dp[n]
O(n) space

After (Rolling):
If dp[i] only depends on dp[i-1] and dp[i-2]:

prev2, prev1, current
O(1) space âœ“

Example:
prev2 = dp[i-2]
prev1 = dp[i-1]
current = prev1 + prev2

Update:
prev2 = prev1
prev1 = current
```

### Two Variables

```
For problems like Fibonacci:

Instead of:
dp = [0, 1, 0, 0, 0, ...]  (size n)

Use:
a = 0
b = 1

For i in range(2, n):
    c = a + b
    a = b
    b = c

Space: O(n) â†’ O(1)
```

---

## ğŸ¯ Step-by-Step Approach

### 1. Identify if it's 1D DP

**Questions to ask:**
- Does state depend on single index?
- Is there optimal substructure?
- Are there overlapping subproblems?
- Can I define dp[i] meaningfully?

### 2. Define the State

**What does dp[i] represent?**
- Maximum/minimum value up to i?
- Number of ways to reach i?
- Whether something is possible at i?
- Length of something ending at i?

### 3. Find Base Cases

**Usually:**
- dp[0] = initial value
- Sometimes dp[1] also needed
- Handle edge cases

### 4. Determine Transition

**How to compute dp[i]?**
- From dp[i-1]?
- From dp[i-2]?
- From all previous dp[j] where j < i?
- Try all possibilities and optimize

### 5. Decide Direction

**Build array:**
- Left to right (most common)
- Right to left (sometimes needed)
- Ensure dependencies are computed first

### 6. Optimize Space

**Can you use:**
- Rolling array?
- Just 2-3 variables?
- In-place modification?

---

## ğŸ¯ Summary

**1D DP is fundamental for sequential problems:**

**Key Characteristics:**
- ğŸ“Š Single dimensional state (dp[i])
- ğŸ”„ Linear dependencies
- âš¡ Often O(n) or O(nÂ²) time
- ğŸ’¾ Space optimizable to O(1)

**Common Patterns:**
1. **Fibonacci-like**: dp[i] = dp[i-1] + dp[i-2]
2. **Max/Min**: dp[i] = max/min(choices at i)
3. **Count ways**: dp[i] = sum of ways from previous
4. **Subsequence**: Check all previous positions
5. **Partition**: Try all split points

**Problem Recognition:**
- âœ… Sequential decisions
- âœ… "Up to position i"
- âœ… "Ending at position i"
- âœ… "Ways to reach i"
- âœ… "Optimal value at i"

**Remember:** If your problem involves making decisions at each position in a sequence, and those decisions depend on previous positions, think **1D DP**!

---

## ğŸ“š Related Topics

- [DP Fundamentals & Patterns](./24_DYNAMIC_PROGRAMMING_BASICS.md) - Foundation
- [2D Dynamic Programming](./26_DP_2D.md) - More complex state
- [Advanced DP Patterns](./27_ADVANCED_DP.md) - Complex techniques
- [Sliding Window](./05_TWO_POINTERS_SLIDING_WINDOW.md) - Related optimization
- [Arrays](./03_ARRAYS.md) - Data structure foundation
