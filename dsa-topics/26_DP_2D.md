# 2D Dynamic Programming

## ğŸ“‹ Overview

**2D Dynamic Programming** involves problems where the optimal solution requires tracking two independent dimensions or parameters. The DP table is a 2D array where `dp[i][j]` represents the solution to a subproblem defined by two indices. These problems typically involve two sequences, grids, or two independent variables.

---

## ğŸ¯ Core Concepts

### What is 2D DP?

In 2D DP:
- **State** requires two indices: `dp[i][j]`
- **DP table** is two-dimensional (matrix)
- **Transitions** depend on adjacent cells or previous states in both dimensions
- **Result** is typically at `dp[m][n]` or needs aggregation

**Characteristics:**
- ğŸ¯ Two-dimensional state space
- ğŸ“Š Matrix/grid representation
- âš¡ Usually O(m Ã— n) time complexity
- ğŸ’¾ Space can sometimes be optimized to O(n)

---

## ğŸ¨ Visual Understanding

### 2D DP Grid Structure

```
Problem: Relating two sequences or navigating a grid

DP Table:
        j â†’ 0    1    2    3    4
    i â†“  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
    0    â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
         â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
    1    â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
         â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
    2    â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
         â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
    3    â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚ ?  â”‚
         â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Each cell dp[i][j] computed from:
- dp[i-1][j] (above)
- dp[i][j-1] (left)
- dp[i-1][j-1] (diagonal)
- Or combination of multiple cells
```

### State Transition Directions

```
Computing dp[i][j]:

     [i-1][j-1]  [i-1][j]
          â†˜         â†“
     [i][j-1]  â†’  [i][j]  â† Current cell
                    â†‘
               Computed from
               previous cells

Common dependencies:
1. From left & top: dp[i][j-1], dp[i-1][j]
2. From diagonal: dp[i-1][j-1]
3. From multiple previous states
```

---

## ğŸ“š Classic 2D DP Problems

### 1. Unique Paths

**Problem:** Robot in mÃ—n grid, can only move right or down. Count paths from top-left to bottom-right.

**Visual Example - 3Ã—4 Grid:**
```
Grid:
    Start
      â†“
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ S â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚   â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚ E â”‚ â† End
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Movements allowed: â†’ (right) or â†“ (down)

DP Table (number of paths to reach each cell):
        j=0  j=1  j=2  j=3
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
i=0   â”‚  1 â”‚  1 â”‚  1 â”‚  1 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
i=1   â”‚  1 â”‚  2 â”‚  3 â”‚  4 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
i=2   â”‚  1 â”‚  3 â”‚  6 â”‚ 10 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Logic:
- First row: 1 way (only right moves)
- First column: 1 way (only down moves)
- Other cells: dp[i][j] = dp[i-1][j] + dp[i][j-1]
              (paths from above + paths from left)

Example - Cell [1][2]:
    Paths from [0][2] (above): 1
    Paths from [1][1] (left): 2
    Total: 1 + 2 = 3 paths

Visual paths to [1][2]:
1. Start â†’ â†’ â†’ â†“
2. Start â†’ â†“ â†’ â†’
3. Start â†“ â†’ â†’ â†‘

Result: 10 unique paths to bottom-right
```

**Recurrence:**
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

---

### 2. Minimum Path Sum

**Problem:** Given mÃ—n grid with numbers, find path from top-left to bottom-right with minimum sum. Can only move right or down.

**Visual Example:**
```
Grid with costs:
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ 1 â”‚ 3 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 5 â”‚ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 4 â”‚ 2 â”‚ 1 â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

DP Table (minimum sum to reach each cell):
        j=0  j=1  j=2
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
i=0   â”‚  1 â”‚  4 â”‚  5 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
i=1   â”‚  2 â”‚  7 â”‚  6 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
i=2   â”‚  6 â”‚  8 â”‚  7 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Building the DP table:

Base cases:
- dp[0][0] = grid[0][0] = 1
- First row: accumulate (1 â†’ 1+3=4 â†’ 4+1=5)
- First column: accumulate (1 â†’ 1+1=2 â†’ 2+4=6)

Cell [1][1]:
    From top: dp[0][1] = 4
    From left: dp[1][0] = 2
    dp[1][1] = grid[1][1] + min(4, 2)
             = 5 + 2 = 7

Cell [1][2]:
    From top: dp[0][2] = 5
    From left: dp[1][1] = 7
    dp[1][2] = grid[1][2] + min(5, 7)
             = 1 + 5 = 6

Cell [2][2]:
    From top: dp[1][2] = 6
    From left: dp[2][1] = 8
    dp[2][2] = grid[2][2] + min(6, 8)
             = 1 + 6 = 7

Minimum path sum: 7
Path: 1 â†’ 3 â†’ 1 â†’ 1 â†’ 1 (sum = 7)
```

**Visual Path:**
```
    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚ 1 â†’ 3 â†’ 1 â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 1 â”‚ 5 â”‚ â†“ â”‚
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚ 4 â”‚ 2 â”‚ 1 â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Optimal: 1+3+1+1+1 = 7
```

**Recurrence:**
```
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
```

---

### 3. Longest Common Subsequence (LCS)

**Problem:** Find length of longest subsequence common to both strings.

**Visual Example - "ABCDE" and "ACE":**
```
String 1: A B C D E
String 2: A C E

DP Table:
          ""  A   B   C   D   E
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
  ""  â”‚  0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  A   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  C   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 2 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  E   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 3 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Building logic:
- If characters match: dp[i][j] = dp[i-1][j-1] + 1
- If not match: dp[i][j] = max(dp[i-1][j], dp[i][j-1])

Step-by-step:

Position [1][1]: 'A' vs 'A'
    Match! dp[1][1] = dp[0][0] + 1 = 1

Position [1][2]: 'A' vs 'B'
    No match. dp[1][2] = max(dp[0][2], dp[1][1])
                       = max(0, 1) = 1

Position [2][3]: 'C' vs 'C'
    Match! dp[2][3] = dp[1][2] + 1 = 2

Position [3][5]: 'E' vs 'E'
    Match! dp[3][5] = dp[2][4] + 1 = 3

LCS length: 3
The subsequence: "ACE"
```

**Visual Subsequence:**
```
String 1: A B C D E
          â†“   â†“   â†“
String 2: A   C   E

Common subsequence: A, C, E (length 3)
```

**Another Example - "AGGTAB" and "GXTXAYB":**
```
          ""  G   X   T   X   A   Y   B
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
  ""  â”‚  0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  A   â”‚  0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  G   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  G   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  T   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 2 â”‚ 2 â”‚ 2 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  A   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 3 â”‚ 3 â”‚ 3 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  B   â”‚  0 â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 3 â”‚ 3 â”‚ 4 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

LCS length: 4
LCS: "GTAB"

Trace back path:
[6][7] B matches â†’ [5][6]
[5][6] A matches â†’ [4][5]
[4][5] take from [3][4] or [4][4]
[4][3] T matches â†’ [3][2]
[3][2] take from [2][1]
[2][1] G matches â†’ [1][0]

Result: G-T-A-B
```

---

### 4. Edit Distance (Levenshtein Distance)

**Problem:** Minimum operations (insert, delete, replace) to convert one string to another.

**Visual Example - Convert "horse" to "ros":**
```
Operations allowed:
- Insert a character
- Delete a character
- Replace a character

DP Table:
          ""  r   o   s
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
  ""  â”‚  0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  h   â”‚  1 â”‚ 1 â”‚ 2 â”‚ 3 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  o   â”‚  2 â”‚ 2 â”‚ 1 â”‚ 2 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  r   â”‚  3 â”‚ 2 â”‚ 2 â”‚ 2 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  s   â”‚  4 â”‚ 3 â”‚ 3 â”‚ 2 â”‚
      â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  e   â”‚  5 â”‚ 4 â”‚ 4 â”‚ 3 â”‚
      â””â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Logic:
- Base cases:
  - Converting "" to "ros": 3 insertions (0â†’1â†’2â†’3)
  - Converting "horse" to "": 5 deletions (5â†’4â†’3â†’2â†’1â†’0)

- If characters match: dp[i][j] = dp[i-1][j-1]
- If not match: dp[i][j] = 1 + min(
    dp[i-1][j],      // delete from s1
    dp[i][j-1],      // insert into s1
    dp[i-1][j-1]     // replace
  )

Position [2][2]: 'o' vs 'o'
    Match! dp[2][2] = dp[1][1] = 1

Position [3][1]: 'r' vs 'r'
    Match! dp[3][1] = dp[2][0] = 2

Position [4][3]: 's' vs 's'
    Match! dp[4][3] = dp[3][2] = 2

Position [5][3]: 'e' vs 's'
    No match. dp[5][3] = 1 + min(
        dp[4][3] = 2,  // delete 'e'
        dp[5][2] = 4,  // insert 's'
        dp[4][2] = 3   // replace 'e' with 's'
    ) = 1 + 2 = 3

Minimum operations: 3
```

**Visual Operations:**
```
horse â†’ ros

Step 1: Replace 'h' with 'r': rorse
Step 2: Delete 'r': rose
Step 3: Delete 'e': ros âœ“

Or:
Step 1: Delete 'h': orse
Step 2: Delete 'r': ose
Step 3: Replace 'e' with 's': oss
... (different path, same cost)
```

---

### 5. Coin Change 2 (Number of Ways)

**Problem:** Count number of ways to make amount with given coins.

**Visual Example - Coins: [1, 2, 5], Amount: 5:**
```
DP Table:
dp[i][j] = ways to make amount j using first i coins

Amount:    0   1   2   3   4   5
         â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
No coins â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚
         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
Coin 1   â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚ 1 â”‚
         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
Coin 2   â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 3 â”‚ 3 â”‚
         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
Coin 5   â”‚ 1 â”‚ 1 â”‚ 2 â”‚ 2 â”‚ 3 â”‚ 4 â”‚
         â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Building:
Base: dp[0][0] = 1 (one way to make 0: use no coins)

Using coin 1:
- Amount 1: 1 way [1]
- Amount 2: 1 way [1,1]
- Amount 5: 1 way [1,1,1,1,1]

Using coins 1,2:
- Amount 2: 2 ways [1,1] or [2]
- Amount 3: 2 ways [1,1,1] or [1,2]
- Amount 4: 3 ways [1,1,1,1] or [1,1,2] or [2,2]
- Amount 5: 3 ways [1,1,1,1,1] or [1,1,1,2] or [1,2,2]

Using coins 1,2,5:
- Amount 5: Add [5] as option
  Ways = ways without coin 5 + ways to make (5-5)
       = 3 + 1 = 4 ways

4 ways to make 5:
1. [1,1,1,1,1]
2. [1,1,1,2]
3. [1,2,2]
4. [5]

Logic:
dp[i][j] = dp[i-1][j] + dp[i][j-coin[i]]
         (don't use coin) + (use coin)
```

---

### 6. Knapsack Problem (0/1 Knapsack)

**Problem:** Given items with weights and values, maximize value in knapsack with capacity W.

**Visual Example - Items: [(w=2, v=3), (w=3, v=4), (w=4, v=5)], Capacity: 5:**
```
DP Table:
dp[i][w] = max value using first i items with capacity w

Capacity:  0   1   2   3   4   5
         â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
0 items  â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚
         â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
Item 1   â”‚ 0 â”‚ 0 â”‚ 3 â”‚ 3 â”‚ 3 â”‚ 3 â”‚
(w=2,v=3)â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
Item 2   â”‚ 0 â”‚ 0 â”‚ 3 â”‚ 4 â”‚ 4 â”‚ 7 â”‚
(w=3,v=4)â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
Item 3   â”‚ 0 â”‚ 0 â”‚ 3 â”‚ 4 â”‚ 5 â”‚ 7 â”‚
(w=4,v=5)â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Item 1 (w=2, v=3):
- Capacity 2-5: Can include item 1
  dp[1][2] = max(0, 0 + 3) = 3
  dp[1][5] = 3

Item 2 (w=3, v=4):
- Capacity 5: Can include item 2
  dp[2][5] = max(
    dp[1][5],           // don't take item 2 = 3
    dp[1][5-3] + 4      // take item 2 = dp[1][2] + 4 = 3 + 4 = 7
  ) = 7
  (Take both items: 1 and 2)

Item 3 (w=4, v=5):
- Capacity 4:
  dp[3][4] = max(
    dp[2][4] = 4,       // don't take item 3
    dp[2][0] + 5 = 5    // take item 3 (alone)
  ) = 5

Maximum value: 7
Items: Item 1 (w=2, v=3) + Item 2 (w=3, v=4)
Total weight: 5, Total value: 7
```

**Visual Decision Tree:**
```
                    [capacity=5]
                   /           \
            Take item 1       Don't take
            (v=3, w=2)        item 1
                 |                 |
            [capacity=3]      [capacity=5]
               /    \            /    \
         Take item2 Don't   Take item2 Don't
         (v=4,w=3)         (v=4,w=3)
             |                  |
         value=7            value=4
         âœ“ Best!
```

---

### 7. Interleaving Strings

**Problem:** Check if string s3 is formed by interleaving s1 and s2.

**Visual Example - s1="aab", s2="axy", s3="aaxaby":**
```
DP Table:
dp[i][j] = can s3[0..i+j-1] be formed by s1[0..i-1] and s2[0..j-1]

        ""  a   x   y
      â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
  ""  â”‚ T â”‚ F â”‚ F â”‚ F â”‚
      â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  a   â”‚ T â”‚ T â”‚ F â”‚ F â”‚
      â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  a   â”‚ T â”‚ T â”‚ T â”‚ F â”‚
      â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  b   â”‚ F â”‚ T â”‚ T â”‚ T â”‚
      â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

s3 = "aaxaby"

Position [2][2]: s1="aa", s2="ax", s3="aaxa"
- Check if s1[1]='a' matches s3[3]='a': Yes
  AND dp[1][2] = true â†’ dp[2][2] = true
- OR s2[1]='x' matches s3[3]='a': No

Position [3][3]: s1="aab", s2="axy", s3="aaxaby"
- Check if s1[2]='b' matches s3[5]='y': No
- OR s2[2]='y' matches s3[5]='y': Yes
  AND dp[3][2] = true â†’ dp[3][3] = true

Visual interleaving:
s1: a   a     b
s2:   a x y
s3: a a x a b y
    â†‘ â†‘ â†‘ â†‘ â†‘ â†‘
    1 1 2 1 1 2
    (source: 1=s1, 2=s2)

Result: True, s3 is valid interleaving
```

---

## ğŸ¯ Problem-Solving Patterns

### Pattern 1: Grid Path Problems

**When to Use:**
- Navigating 2D grid
- Moving in limited directions
- Counting paths or finding optimal path

**Examples:**
- Unique paths
- Minimum path sum
- Dungeon game

**Recurrence:**
```
dp[i][j] = combine(dp[i-1][j], dp[i][j-1])
```

---

### Pattern 2: Two Sequence Comparison

**When to Use:**
- Comparing two strings/arrays
- Finding common elements
- Transformation between sequences

**Examples:**
- Longest common subsequence
- Edit distance
- Distinct subsequences

**Recurrence:**
```
If s1[i] == s2[j]:
    dp[i][j] = dp[i-1][j-1] + 1
Else:
    dp[i][j] = operation on previous states
```

---

### Pattern 3: Knapsack Variations

**When to Use:**
- Making choices with constraints
- Capacity/weight limitations
- Selecting subset of items

**Examples:**
- 0/1 knapsack
- Partition equal subset sum
- Target sum

**Recurrence:**
```
dp[i][w] = max(
    dp[i-1][w],              // don't take item i
    dp[i-1][w-weight[i]] + value[i]  // take item i
)
```

---

### Pattern 4: Matrix Chain Multiplication

**When to Use:**
- Breaking problem into subproblems
- Range optimization
- Partitioning decisions

**Examples:**
- Matrix chain multiplication
- Burst balloons
- Palindrome partitioning

**Recurrence:**
```
dp[i][j] = min/max over all k in [i, j]:
    dp[i][k] + dp[k+1][j] + cost(i, j, k)
```

---

## ğŸ’¡ Space Optimization

### 1D Array Optimization

**Concept:** When dp[i][j] only depends on current and previous row.

```
Original (2D):
dp[m][n] - O(m Ã— n) space

Optimized (1D):
prev[n], curr[n] - O(n) space

Or even:
single dp[n] array, update in place
```

**Example - LCS:**
```
Original:
dp[i][j] depends on:
- dp[i-1][j-1] (diagonal)
- dp[i-1][j] (above)
- dp[i][j-1] (left)

Optimized:
Keep only previous row:
prev[j] = previous row
curr[j] = current row

After computing row i:
prev = curr
```

---

## ğŸ¯ Step-by-Step Approach

### 1. Identify 2D DP

**Questions:**
- Do I need two indices to define state?
- Am I comparing two sequences?
- Is it a grid-based problem?
- Do I have two independent parameters?

### 2. Define State

**What does dp[i][j] represent?**
- Optimal value for first i items with capacity j?
- Solution for s1[0..i] and s2[0..j]?
- Result at grid position (i, j)?
- Cost/count for subproblem [i, j]?

### 3. Determine Base Cases

**Usually:**
- First row and column (dp[0][j], dp[i][0])
- Empty string/array cases
- When one dimension is 0

### 4. Find Recurrence Relation

**How does dp[i][j] relate to:**
- dp[i-1][j] (above)?
- dp[i][j-1] (left)?
- dp[i-1][j-1] (diagonal)?
- Other cells?

### 5. Fill Table

**Order:**
- Row by row, left to right (most common)
- Column by column
- Diagonal by diagonal (rare)

### 6. Extract Answer

**Where is the result?**
- dp[m][n] (bottom-right)
- Max/min of last row/column
- Aggregation of multiple cells

---

## ğŸ¯ Summary

**2D DP handles multi-dimensional problems:**

**Key Characteristics:**
- ğŸ“Š Two-dimensional state (dp[i][j])
- ğŸ¯ Grid or two-sequence problems
- âš¡ O(m Ã— n) time typically
- ğŸ’¾ Space optimizable to O(n) often

**Common Problem Types:**
1. **Grid Navigation**: Paths, costs in 2D grids
2. **String Matching**: LCS, edit distance, interleaving
3. **Knapsack**: Item selection with constraints
4. **Range DP**: Matrix chain, burst balloons

**Pattern Recognition:**
- âœ… Two sequences to compare
- âœ… Grid-based movement
- âœ… Two independent parameters
- âœ… "For each position (i, j)"
- âœ… "Comparing up to i and j"

**Remember:** If your problem involves two sequences, a 2D grid, or needs two indices to define the state, think **2D DP**!

---

## ğŸ“š Related Topics

- [1D Dynamic Programming](./25_DP_1D.md) - Simpler state space
- [DP Fundamentals & Patterns](./24_DYNAMIC_PROGRAMMING_BASICS.md) - Foundation
- [Advanced DP Patterns](./27_ADVANCED_DP.md) - Complex variations
- [String Processing](./04_STRINGS.md) - String problems
- [Arrays](./03_ARRAYS.md) - Grid representation
